function [W_mouse,core_comm_size] = WithinMouseBasisMotifs(W_all,nanpxs,opts,mouseid,cluster_idx,idx_knn,lag_mat,lags)
%camden macdowell - timeless
%mose inputs generated by the output of ClusterW. 
%use the clustering across all animals, to generate basis motifs per each
%mouse in mouseid. 
%returns core_comm_size for later gutchecks. 

unique_mice = unique(mouseid);

%match the cluster_idx
mouseid_all = arrayfun(@(n) ones(size(W_all{n},2),1)*mouseid(n),1:numel(mouseid),'UniformOutput',0);
mouseid_all = cat(1,mouseid_all{:});

%loop through mice and combine the motifs for that animal
W_mouse = cell(1,numel(unique_mice));
core_comm_size = cell(1,numel(unique_mice));
for cur_mouse = 1:numel(unique_mice)
    fprintf('\n\t Working on mouse %d of %d',cur_mouse,numel(unique_mice));
    %confirm that all nanpxs masks are the same for this animal (required)
    try temp_nanpxs = cat(1,nanpxs{mouseid==unique_mice(cur_mouse)}); catch; error('nanpxs masks for the current animal are not consistent across recordings'); end
    temp_nanpxs = temp_nanpxs(1,:);
    
    if iscell(W_all) %combine mutliple CNMF Fits stored in a cell array
        W = cat(2,W_all{mouseid==unique_mice(cur_mouse)});
    end

    %Remove empty motifs (legacy compatibility)
    [W,~,indempty] = RemoveEmptyMotifs(W);    
    if ~isempty(indempty)
        idx = find(mouseid_all==unique_mice(cur_mouse)); %indices of cur mouse
        mouseid_all(idx(indempty))=[];
    end
    
    [~, ~, L] = size(W);
    
    %get the clustering info for this animal 
    idx = find(mouseid_all==unique_mice(cur_mouse)); %indices of cur mouse
    temp_cluster_idx = cluster_idx(idx);
    temp_idx_knn = idx_knn(idx,:);
    temp_idx_knn(~ismember(temp_idx_knn,idx))=NaN; %only keeps neighbors from same animal 
    temp_idx_knn = temp_idx_knn-min(temp_idx_knn)+1; %adjust for the shift of a middle animal
    temp_lag_mat = lag_mat(idx,idx);   
    
    %optional 2D or 3D gaussian smooth. Reccomended for noisy data. 
    if ~isempty(opts.clust_smooth_kernel)
        W_smooth = GaussianSmoothTensor(W,opts.clust_smooth_kernel,opts.originaldimensions,temp_nanpxs,opts.clust_nobleed);
    else
        W_smooth = W; 
    end
        
    %Reconstruct full W. This is used for averaging to make the basis motifs. 
    W = MaskTensor(W,temp_nanpxs,[opts.originaldimensions(1)*opts.originaldimensions(2),size(W,2),size(W,3)]); 

    fprintf('\n\tGenerating Basis Motifs for mouse %d',unique_mice(cur_mouse))
    %Get core community to average for basis motifs
    if numel(opts.clust_community_fraction)>1 %find the best core_community_fraction
        fprintf('\n\t Autofitting Community Fractions');
        [core_comm_idx, core_comm_size{cur_mouse}] = AutoFitCommunityFraction(temp_cluster_idx,temp_idx_knn,opts,W_smooth,temp_lag_mat,lags);               
    else %just take the set value
        fprintf('\n\t Using Set Community Fraction');
        [core_comm_idx, core_comm_size{cur_mouse}] = CoreCommunity(temp_cluster_idx,temp_idx_knn,opts.clust_community_fraction); 
    end

    %Allign motifs in each cluster to one of the core community members 
    fprintf('\n\tAlligning W')
    W_alligned = AllignW(W,core_comm_idx,lags,temp_cluster_idx,temp_lag_mat);

    %compute basis motifs
    fprintf('\n\tComputing Basis Motifs')
    W_basis = NaN(size(W,1),numel(core_comm_idx),size(W_alligned,3));
    for i = 1:numel(core_comm_idx)   
        W_basis(:,i,:) = nanmean(W_alligned(:,core_comm_idx{i},:),2);
    end

    %optional removal of the padded pixels
    if opts.clust_removepad
       W_basis = ShiftW(W_basis); %center shift before optional 
       W_basis = W_basis(:,:,L+1:L*2);
    else %just remove totally empty regions
       W_basis = W_basis(:,:,nanvar(squeeze(sum(W_basis,1)),[],1)>eps);
    end   
    W_mouse{cur_mouse} = W_basis;
end

end %funciton end 
    